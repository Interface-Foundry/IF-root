// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙⚪💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙⚪⚪⚪❤🎀⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙🌚❤🎀🎀🎀🎀⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙🎀🎀🎀👕🎀💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙🎀🎀💙💙👕💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙👕💙💙💙💙💙💙💙💙💙⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙⚪⚪⚪⚪
// ⚪⚪⚪⚪💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙⚪⚪⚪
// ⚪⚪⚪💙💙💙💙💙💙💙💙💙💭💭💙💭💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙💙⚪⚪
// ⚪⚪⚪💙💙💙💙💙💙💙⚪🌚⚪⚪⚪⚪⚪💭💭💙💙💙💙💙💙⚪⚪💭💭💭⚪⚪💙💙💙💙💙💙⚪⚪
// ⚪⚪💙💙💙💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💭⚪⚪⚪⚪⚪⚪⚪💭💙💙💙💙💙💙⚪
// ⚪⚪💙💙💙💙💙💙🌚⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💭💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙💙⚪
// ⚪💙💙💙💙💙💙💭⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙🌚⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💭💙💙💙💙💙
// ⚪💙💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙
// ⚪💙💙💙💙💙⚪⚪⚪⚪⚫⚫⚫⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚫⚫⚫⚪⚪⚪⚪⚪💙💙💙💙
// ⚪💙💙💙💙💙⚪⚪⚪🌚⚫⚫⚫⚪⚪⚪⚪⚪⚪⚪🌚🌚⚪⚪⚪⚪⚪⚫⚫⚫⚫⚪⚪⚪⚪⚪💙💙💙💙
// ⚪💙💙💙💙💙⚪⚪⚪🌕⚫⚫⚫⚪⚪⚪⚪🍊🍊🍊🍊🍊🍊🍊⚪⚪⚪🌚⚫⚫⚫⚪⚪⚪⚪⚪💙💙💙💙
// ⚪💙💙💙💙💙⚪⚪⚪⚪🌕⚪⚪⚪⚪⚪🍊🍊🍊🍊🍊🍊🍊🍊🍊⚪⚪⚪🌕⚪⚪⚪⚪⚪⚪⚪💙💙💙💙
// ⚪💙💙💙💙💙🐙⚪⚪⚪⚪⚪⚪⚪⚪⚪💰🍊🍊🍊🍊🍊🍊🍊⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙
// ⚪⚪💙💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💛⚪💛⚪🍊⚪💰⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙
// ⚪⚪💙💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙
// ⚪⚪⚪💙💙💙💙🐙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙⚪
// ⚪⚪⚪💙💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙💙⚪
// ⚪⚪⚪⚪💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙💙💙⚪⚪
// ⚪⚪⚪⚪⚪💙💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪🐙💙💙⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪💙💙💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪💙⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪🌚💙⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
// ⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪⚪
//Cinna 0.4 (Pepper)

var http = require('http');
var fs = require('fs');
var Bot = require('slackbots'); //load slack api
var request = require('request');
var async = require('async');
var amazon = require('./amazon-product-api_modified'); //npm amazon-product-api
var nlp = require('../nlp/api');


//load mongoose models
var db = require('db');
var Message = db.Message;
var Slackbots = db.Slackbots;

//set env vars
var config = require('config');

process.on('uncaughtException', function (err) {
  console.error('uncaught exception', new Date())
  console.error(err.stack);
});


//load kip modules
var banter = require("./components/banter.js");
var purchase = require("./components/purchase.js");
var history = require("./components/history.js");
var search = require("./components/search.js");
var picstitch = require("./components/picstitch.js");
var processData = require("./components/process.js");

var client = amazon.createClient({
  awsId: "AKIAILD2WZTCJPBMK66A",
  awsSecret: "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",
  awsTag: "bubboorev-20"
});

// website 🌏
var express = require('express');
var app = express();
var server = require('http').createServer(app);
app.use(express.static(__dirname + '/static'))
app.get('/healthcheck', function () {
  res.send('💬 🌏')
})
server.listen(8000, function(e) {
  if (e) { console.error(e) }
  console.log('chat app listening on port 8000 🌏 💬')
})


//globals
var messageHistory = {}; //fake database, stores all users and their chat histories
var slackUsers = {};
    
//- - - - Slack handling - - - -//
initSlackUsers();

//get stored slack users from mongo
function initSlackUsers(){
    console.log(app.get('env'));
    //load kip-pepper for testing
    if ( app.get('env') === 'development' ) {
        var testUser = [{
            team_id:'T0H72FMNK',
            bot: {
                bot_user_id: 'U0H6YHBNZ',
                bot_access_token:'xoxb-17236589781-HWvs9k85wv3lbu7nGv0WqraG'
            },
            meta: {
                initialized: false
            }
        }];
        loadSlackUsers(testUser);
    }else {
        console.log('retrieving slackbots from mongo');
        Slackbots.find().exec(function(err, users) {
            if(err){
                console.log('saved slack bot retrieval error');
            }
            else {
                loadSlackUsers(users);
            }
        });        
    }
}

//incoming new slack user
app.get('/newslack', function(req, res) {

    //find all bots not added to our system yet
    Slackbots.find({'meta.initialized': false}).exec(function(err, users) {
        if(err){
            console.log('saved slack bot retrieval error');
        }
        else {
            loadSlackUsers(users);
            res.send('slack user added');

            //update all to initialized
            async.eachSeries(users, function(user, callback) {
                user.meta.initialized = true;
                user.save( function(err, data){
                    if(err){
                        console.log('Mongo err ',err);
                    }
                    else{
                        console.log('mongo res ',data);
                    }
                    callback();
                });
            }, function done(){
                console.log('initialized all new bots');
            });
        }
    });
});

//load slack users into memory, adds them as slack bots
function loadSlackUsers(users){
    console.log('loading '+users.length+' Slack users');

    async.eachSeries(users, function(user, callback) {

        if (user.bot && !user.bot.bot_access_token && !user.bot.bot_user_id){
            console.log('ERROR: bot token and id missing from DB for ',user);
        }

        var settings = {
            token: user.bot.bot_access_token,
            name: 'Kip'
        };

        //create new bot from user settings
        slackUsers[user.team_id] = new Bot(settings);
        slackUsers[user.team_id].botId = user.bot.bot_user_id;

        //init new bot
        slackUsers[user.team_id].on('start', function() {

            //* * * * Welcome message * * * //
            //send welcome to new teams – dont spam all slack people on node reboot
            if (user.meta && user.meta.initialized == false){
                //* * * * send welcome message
                //get list of users in team
                request('https://slack.com/api/im.list?token='+user.bot.bot_access_token+'', function(err, res, body) {
                  if(err){
                    console.log('requesting new team user list error: ',err);
                  }
                  else {
                    body = JSON.parse(body);

                    if (body.ok && body.ims.length > 0){
                        //loop through members, commence welcome!
                        async.eachSeries(body.ims, function(member, callback) {
                            if (member.is_user_deleted == false && member.is_im == true && member.user !== 'USLACKBOT'){
                                var hello = {
                                    msg: 'welcome'
                                }
                                hello.source = {
                                    'origin':'slack',
                                    'channel':member.id,
                                    'org':user.team_id,
                                    'id':user.team_id + "_" + member.id //for retrieving chat history in node memory
                                }
                                banter.welcomeMessage(hello,function(res){
                                    sendTxtResponse(hello,res);
                                });
                            }
                            callback();
                        }, function done(){
                            console.log('finished sending out welcome messages to new team');
                        });
                    }
                    else {
                        console.log('error: something happened, a ghost slack team emerged');
                    }
                  }
                });
            }
            // * * * * * * * * * * //

            //on message from slack user
            slackUsers[user.team_id].on('message', function(data) { //on bot message
                // all incoming events https://api.slack.com/rtm
                // if (data.type == 'presence_change'){
                //     console.log('CHANGEGEE ',data);
                //     slackUsers[user.team_id].botId = data.user; //get bot user id for slack team
                // }
                if (data.type == 'message' && data.username !== settings.name && data.hidden !== true){
                    //public channel
                    if (data.channel && data.channel.charAt(0) == 'C'){
                        //if contains bot user id (U0H6YHBNZ)
                        if (data.text && data.text.indexOf(slackUsers[user.team_id].botId) > -1){
                            data.text = data.text.replace(/(<([^>]+)>)/ig, ''); //remove <user.id> tag
                            if (data.text.charAt(0) == ':'){
                                data.text = data.text.substr(1); //remove : from beginning of string
                            }
                            data.text = data.text.trim(); //remove extra spaces on edges of string
                            incomingSlack(data);
                        }
                    }
                    //direct message
                    else if (data.channel && data.channel.charAt(0) == 'D'){
                        incomingSlack(data);
                    }    
                }
                function incomingSlack(data){
                    if (data.type == 'message' && data.username !== settings.name && data.hidden !== true ){
                        var newSl = {
                            source: {
                                'origin':'slack',
                                'channel':data.channel,
                                'org':data.team,
                                'id':data.team + "_" + data.channel, //for retrieving chat history in node memory,
                            },
                            'msg':data.text
                        }
                        preProcess(newSl);
                    }                    
                }
            });
        });

        callback();
    }, function done(){
        console.log('done loading slack users');
    });
}

//- - - - Socket.io handling - - - -//
var io = require('socket.io').listen(server);
io.sockets.on('connection', function(socket) {
    console.log("socket connected");

    //* * * * send welcome message
    var hello = {
        msg: 'welcome'
    }
    hello.source = {
        'origin':'socket.io',
        'channel':socket.id,
        'org':'kip',
        'id':'kip' + "_" + socket.id //for retrieving chat history in node memory
    }
    banter.welcomeMessage(hello,function(res){
        sendTxtResponse(hello,res);
    });
   // * * * * * * * * * * //
    
    socket.on("msgToClient", function(data) {
        data.source = {
            'origin':'socket.io',
            'channel':socket.id,
            'org':'kip',
            'id':'kip' + "_" + socket.id //for retrieving chat history in node memory
        }
        preProcess(data);
    });
});
//- - - - - - //


//pre process incoming messages for canned responses
function preProcess(data){

    //setting up all the data for this user / org
    if (!data.source.org || !data.source.channel){
        console.log('missing channel or org Id 1');
    }
    if (!messageHistory[data.source.id]){ //new user, set up chat states
        messageHistory[data.source.id] = {};
        messageHistory[data.source.id].search = []; //random chats
        messageHistory[data.source.id].banter = []; //search
        messageHistory[data.source.id].purchase = []; //finalizing search and purchase
        messageHistory[data.source.id].persona = []; //learn about our user
        messageHistory[data.source.id].cart = []; //user shopping cart
        messageHistory[data.source.id].allBuckets = []; //all buckets, chronological chat history
    }

    //check for canned responses/actions before routing to NLP
    banter.checkForCanned(data.msg,function(res,flag,query){
        //found canned response
        if(flag){
            data.client_res = [];
            switch(flag){
                case 'basic': //just respond, no actions
                    //send message
                    data.client_res = [];
                    data.client_res.push(res);
                    cannedBanter(data);
                    break;
                case 'search.initial':
                    //send message
                    data.client_res = [];
                    data.client_res.push(res);
                    cannedBanter(data);

                    //now search for item
                    data.tokens = [];
                    data.tokens.push(query); //search for this item
                    data.bucket = 'search';
                    data.action = 'initial';
                    incomingAction(data);
                    break;
                case 'search.focus':
                    data.searchSelect = [];
                    data.searchSelect.push(query);
                    data.bucket = 'search';
                    data.action = 'focus';
                    incomingAction(data);
                    break;
                default:
                    console.log('error: canned action flag missing');
            }
        }
        //proceed to NLP instead
        else {
            routeNLP(data);
        }
    },data.source.origin);

  //  });

}

//pushing incoming messages to python
function routeNLP(data){

    nlp.parse(data.msg, function(e, res) {
        if (e){console.log('NLP error ',e)}
        else {
            console.log('NLP RES ',res);

            if(!res.bucket){
                res.bucket = 'search';
            }
            if(!res.action){
                res.action = 'initial';
            }

            //- - - temp stuff to transfer nlp results to data object - - - //
            if (res.bucket){
                data.bucket = res.bucket;
            }
            if (res.action){
                data.action = res.action;
            }
            if (res.tokens){
                data.tokens = res.tokens;
            }
            if (res.searchSelect){
                data.searchSelect = res.searchSelect;
            }
            if (res.dataModify){
                data.dataModify = res.dataModify;
            }
            //- - - - end temp - - - - //

            incomingAction(data);

        }

    })
}

//sentence breakdown incoming from python
function incomingAction(data){

    //save a new message obj
    history.saveHistory(data,true); //saving incoming message
    
    //sort context bucket (search vs. banter vs. purchase)
    switch (data.bucket) {
        case 'search':
            searchBucket(data);
            break;
        case 'banter':
            banterBucket(data);
            break;
        case 'purchase':
            purchaseBucket(data);
            break;
        case 'supervisor':
            //route to supervisor chat window
        default:
            searchBucket(data);
    }
}

//* * * * * ACTION CONTEXT BUCKETS * * * * * * *//

function searchBucket(data){
    //sort search action type
    switch (data.action) {
        case 'initial':
            searchInitial(data);
            break;
        case 'similar':
            searchSimilar(data);
            break;
        case 'modify':
        case 'modified': //because the nlp json is wack
            searchModify(data);
            break;
        case 'focus':
            searchFocus(data);
            break;
        case 'back':
            searchBack(data);
            break;
        case 'more':
            searchMore(data); //Search more from same query
            break;
        default:
            searchInitial(data);
    }
}

function banterBucket(data){
    //sort search action type
    switch (data.action) {
        case 'question':
            break;
        case 'smalltalk':
            outgoingResponse(data,'txt');
            break;
        default:
    }
}

function purchaseBucket(data){
    //sort purchase action
    switch (data.action) {
        case 'save':
            saveToCart(data);
            break;
        case 'remove':
            removeFromCart(data);
            break;
        case 'removeAll':
            removeAllCart(data);
            break;
        case 'list':
            listCart(data);
            break;
        case 'checkout':
            saveToCart(data);
        default:
            console.log('error: no purchase bucket action selected');
    }
}

//* * * * * SEARCH ACTIONS * * * * * * * * //

function searchInitial(data,flag){
    searchAmazon(data,'initial','none',flag);
}

function searchSimilar(data){

    if (data.dataModify){
        data.action = 'modify'; //because NLP changed randomly =_=;
        searchModify(data);  
    }
    else {
        //RECALL LAST ITEM IN SEARCH HISTORY
        history.recallHistory(data, function(item){
            data.recallHistory = item; //added recalled history obj to data obj
            searchAmazon(data,'similar');
        });       
    }


}

function searchModify(data, flag){

    //A child ASIN would be a blue shirt, size 16, sold by MyApparelStore
    // http://docs.aws.amazon.com/AWSECommerceService/latest/DG/Variations_VariationDimensions.html

    //RECALL LAST ITEM IN SEARCH HISTORY
    history.recallHistory(data, function(item){

        if (item){//history item found

            data.recallHistory = item;

            var cSearch = ''; //construct new search string

            //CONSTRUCT QUERY FROM AMAZON OBJECT
            if (data.recallHistory.amazon){

                if (data.dataModify && data.dataModify.type){
                    //handle special modifiers that need care, consideration, hard tweaks of amazon search API

                    //ugh dead
                    if (data.dataModify.val){
                        var dumbVar = data.dataModify.val[0];
                    }
                    else {
                        var dumbVar = '';
                    }
                     
                    switch (data.dataModify.type) {
                        case 'price':
                            searchInitial(data,{ // passing special FLAG for search to handle
                                'type':data.dataModify.type,
                                'param':data.dataModify.param,
                                'val':dumbVar
                            });
                            break;

                        case 'brand':
                            searchInitial(data,{ // passing special FLAG for search to handle
                                'type':data.dataModify.type,
                                'val':dumbVar
                            });
                            break;

                        default:
                            constructAmazonQuery(); //nm just construct a new query
                    }
                }
                else {
                    console.log('error: data.dataModify params missing')
                }

                function constructAmazonQuery(){

                    async.eachSeries(data.searchSelect, function(searchSelect, callback) {

                        var itemAttrib = data.recallHistory.amazon[searchSelect - 1].ItemAttributes; //get selected item attributes

                        //DETAILED SEARCH, FIRED IF FLAG weakSearch not on
                        if (flag !== 'weakSearch'){
                            console.log('weakSearch FALSE');
                            //add brand
                            if (itemAttrib[0].Brand){
                                cSearch = cSearch + ' ' + itemAttrib[0].Brand[0];
                            }
                            //add clothing size
                            if (itemAttrib[0].ClothingSize){
                                cSearch = cSearch + ' ' + itemAttrib[0].ClothingSize[0];
                            }
                        }
                        else {
                            console.log('weakSearch TRUE');
                        }
                        if (itemAttrib[0].Department){
                            cSearch = cSearch + ' ' + itemAttrib[0].Department[0];
                        }
                        if (itemAttrib[0].ProductGroup){
                            cSearch = cSearch + ' ' + itemAttrib[0].ProductGroup[0];
                        }
                        if (itemAttrib[0].Binding){
                            cSearch = cSearch + ' ' + itemAttrib[0].Binding[0];
                        }

                        callback();
                    }, function done(){
                        addModifier(); //done processing constructing new search, add modifier and run query
                    });
                }
            }
            else {
                console.log('no Amazon data found in last history item. can not modify search');
                data.action = 'initial';
                searchInitial(data); //do a search anyway
            }
        }
        else { //no item history found 
            console.log('warning: no history item found for modification query');
            data.action = 'initial';
            searchInitial(data); //do a search anyway
        }

        //after query construction, add modifier and fire search
        function addModifier(){

            cSearch = cSearch.toLowerCase();

            //SORT WHICH TRAITS TO MODIFY
            switch (data.dataModify.type) {
                // CASES: color, size, price, genericDetail
                case 'color':

                    //remove colors from item name for new search with new color
                    var CSS_COLOR_NAMES = ["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgrey","lightgreen","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"];
                    async.eachSeries(CSS_COLOR_NAMES, function(i, callback) {
                        cSearch = cSearch.replace(i,'');
                        callback();
                    }, function done(){
                        cSearch = data.dataModify.val[0].name + ' ' + cSearch; //add new color
                        data.tokens[0] = cSearch; //replace search string in data obj
                        searchInitial(data,flag); //do a new search
                    });

                    break;

                case 'size':

                    var SIZES = ["xxxs","xxs"," xs ","extra small"," s ","small"," m ","medium"," l ", "large"," xl ","extra large","xxl","xxxl","xxxxl","slimfit"," slim ","skinny", "petite", "plus size", "chubby", " big ", "curvy", " hourglass ", "rectangle-body", "triangle-body", "apple-shape", "pear-shape"];
                    async.eachSeries(SIZES, function(i, callback) {
                        cSearch = cSearch.replace(i,'');
                        callback();
                    }, function done(){
                        cSearch = data.dataModify.val[0] + ' ' + cSearch; //add new color
                        data.tokens[0] = cSearch; //replace search string in data obj
                        searchInitial(data,flag); //do a new search
                    });
                    break;

                //texture, fabric, coating, etc
                case 'material':

                    cSearch = data.dataModify.val[0] + ' ' + cSearch; //add new color
                    data.tokens[0] = cSearch; //replace search string in data obj
                    searchInitial(data,flag); //do a new search
                    break;

                //unsortable modifier
                case 'genericDetail':
                    //FIXING random glitch. GLITCH NLP should output this to "purchase" bucket, "save" action. temp fix
                    if (data.dataModify.val == 'buy'){
                        data.bucket = 'purchase';
                        data.action = 'save';
                        saveToCart(data);
                    }
                    //normal action here
                    else {
                        //SORT THROUGH RESULTS OF SIZES, FILTER
                        cSearch = data.dataModify.val + ' ' + cSearch; //add new color
                        data.tokens[0] = cSearch; //replace search string in data obj
                        searchInitial(data,flag); //do a new search                        
                    }
                    break;
            }
        }
    });

}

function searchFocus(data){

    history.recallHistory(data, function(item){
        data.recallHistory = item; //added recalled history obj to data obj

        if (data.searchSelect && data.searchSelect.length == 1){ //we have something to focus on
            if(data.recallHistory && data.recallHistory.amazon){

                var searchSelect = data.searchSelect[0] - 1;

                if (data.recallHistory.amazon[searchSelect]){

                    var attribs = data.recallHistory.amazon[searchSelect].ItemAttributes[0];
                    var cString = ''; //construct text reply
                    data.client_res = []; //building order of msg delivery to user

                    // * * * * * Building response message array * * * * * //
                    //check for large image to send back
                    if (data.recallHistory.amazon[searchSelect].LargeImage && data.recallHistory.amazon[searchSelect].LargeImage[0].URL[0]){
                        data.client_res.push(data.recallHistory.amazon[searchSelect].LargeImage[0].URL[0]);
                    }
                    //push number emoji + item URL
                    processData.getNumEmoji(data,searchSelect+1,function(res){
                        data.client_res.push(res + ' ' + data.recallHistory.urlShorten[searchSelect]);
                        dumbFunction(); //fire after get 
                    })

                    //pointless ¯\_(ツ)_/¯ ... just makes sure the emoji number + product URL go first in msg order
                    function dumbFunction(){
                        //send product title + price
                        var topStr = attribs.Title[0];

                        //if realprice exists, add it to title
                        if (data.recallHistory.amazon[searchSelect].realPrice){
                            topStr = data.recallHistory.amazon[searchSelect].realPrice + " – " + topStr;
                        }

                        //Make top line bold
                        if (data.source.origin == 'slack'){ 
                            topStr = '*'+topStr+'*';
                        }else if (data.source.origin == 'socket.io'){
                            topStr = '<b>'+topStr+'</b>';
                        }

                        data.client_res.push(topStr);

                        ///// build product details string //////

                        //get size
                        if (attribs.Size){
                            cString = cString + ' ○ ' + "Size: " +  attribs.Size[0];
                        }

                        //get artist
                        if (attribs.Artist){
                            cString = cString + ' ○ ' + "Artist: " +  attribs.Artist[0];
                        }

                        //get brand or manfacturer
                        if (attribs.Brand){
                            cString = cString + ' ○ ' +  attribs.Brand[0];
                        }
                        else if (attribs.Manufacturer){
                            cString = cString + ' ○ ' +  attribs.Manufacturer[0];
                        }

                        //get all stuff in details box
                        if (attribs.Feature){
                            cString = cString + ' ○ ' + attribs.Feature.join(' ░ ');
                        }

                        //done collecting details string, now send
                        if (cString){
                            data.client_res.push(cString);
                            //outgoingResponse(data,'final');
                        }
                        ///// end product details string /////

                        //get review
                        if (data.recallHistory.amazon[searchSelect].reviews && data.recallHistory.amazon[searchSelect].reviews.rating){
                            data.client_res.push('⭐️ ' +  data.recallHistory.amazon[searchSelect].reviews.rating + ' – ' + data.recallHistory.amazon[searchSelect].reviews.reviewCount + ' reviews');
                        }
                        
                        outgoingResponse(data,'final');

                    }


                }else {
                    console.log('warning: item selection does not exist in amazon array');
                    sendTxtResponse(data,'Oops sorry, My brain just broke for a sec, what did you ask?');
                }
            }else {
                console.log('error: amazon search missing from recallHistory obj');
                sendTxtResponse(data,'Oops sorry, I\'m not sure which item you\'re referring to');
            }
        }else {
            console.log('error: you can only select one item for search focus');
            sendTxtResponse(data,'Oops sorry, My brain just broke for a sec, what did you ask?');
        }
    });
}

function searchMore(data){

    history.recallHistory(data, function(res){

        //build new data obj so there's no mongo duplicate
        data = {};
        data.amazon = res.amazon;
        data.source = res.source;
        data.bucket = res.bucket;
        data.action = res.action;
        data.msg = res.msg;
        data.tokens = res.tokens;

        if (data.amazon.length > 3){ //only trim down in thirds for now
            data.amazon.splice(0, 3);
        }

        var loopLame = [0,1,2];//lol
        async.eachSeries(loopLame, function(i, callback) {
            if (data.amazon[i]){
                //get reviews by ASIN 
                search.getReviews(data.amazon[i].ASIN[0],function(rating,reviewCount){

                    //adding scraped reviews to amazon objects
                    data.amazon[i].reviews = {
                        rating: rating,
                        reviewCount: reviewCount
                    }

                    //GET PRICE
                    search.getPrices(data.amazon[i],function(realPrice){
                        data.amazon[i].realPrice = realPrice;
                        callback();
                    });

                    //shorten URLS here

                });
            }
            else {
                callback();
            }

        }, function done(){
            outgoingResponse(data,'stitch','amazon'); //send back msg to user
        });

    });

    //go to end of search results array (3 at a time). if hit end of search array V
    //use amazon search itemPage to advance to more results
}

function searchBack(data){
    //SKIP BACK to history items (use recallHistory w. # of steps == 2)
}

//* * * * * BANTER ACTIONS * * * * * * * * //




//* * * * * * ORDER ACTIONS * * * * * * * * //

//save amazon item to cart
function saveToCart(data){

    data.bucket = 'search'; //modifying bucket to recall search history. a hack for now

    history.recallHistory(data, function(item){

        data.bucket = 'purchase'; //modifying bucket. a hack for now

        //no saved history search object
        if (!item){
            console.log('warning: NO ITEMS TO SAVE TO CART from data.amazon');
            //cannedBanter(data,'Oops sorry, I\'m not sure which item you\'re referring to');
            sendTxtResponse(data,'Oops sorry, I\'m not sure which item you\'re referring to');
        }
        else {
            
            //async push items to cart
            async.eachSeries(data.searchSelect, function(searchSelect, callback) {
                if (item.recallHistory && item.recallHistory.amazon){
                    messageHistory[data.source.id].cart.push(item.recallHistory.amazon[searchSelect - 1]); //add selected items to cart
                }else {
                    messageHistory[data.source.id].cart.push(item.amazon[searchSelect - 1]); //add selected items to cart
                }
                callback();
            }, function done(){
                purchase.outputCart(data,messageHistory[data.source.id],function(res){
                    processData.urlShorten(res, function(res2){
                        res.client_res = [];
                        res.client_res.push(res2);
                        outgoingResponse(res,'txt');
                    });
                });
            });            
        }

    });
}

function viewCart(data){
    db.Metrics.log('cart.view', data);
}

//* * * * * * PROCESS ACTIONS * * * * * * * //

//searches Amazon
//(NEED TO MODIFY TO BE SEARCH PLATFORM AGNOSTIC -> modify search function per platform type, i.e. Kip search vs. Amazon search)
function searchAmazon(data, type, query, flag){

    //* * * * * * * * *  NN CLASSIFICATION NEEDED * * * * * * * * //
    // & & & & & & & & & & & & & & & & & & & & & & & & & & & & & &//
    // * * * * CLASSIFY incoming searches into categories --> search amazon with BrowseNode ---> better results

    //sort query type
    switch (type) {
        case 'initial':

            //add some amazon query params
            var amazonParams = {};
            amazonParams.Keywords = data.tokens[0]; //text search string
            amazonParams.responseGroup = 'ItemAttributes,Images,OfferFull';

            //check for flag to modify amazon search params
            if (flag && flag.type){ //search modifier

                //parse flags
                if (flag.type == 'price'){

                    //TEMPORARY
                    if (flag.param == 'less than'){
                        flag.param = 'less';
                    }

                    switch (flag.param) {
                        case 'less':

                            var searchSelect = data.searchSelect[0] - 1;

                            //there's a price for the item
                            if (data.recallHistory && data.recallHistory.amazon && data.recallHistory.amazon[searchSelect].realPrice){

                                var modPrice = data.recallHistory.amazon[searchSelect].realPrice;

                                modPrice = modPrice.replace('$','');
                                modPrice = modPrice.replace('.','');

                                modPrice = parseInt(modPrice);
                                
                                var per = modPrice * .35; //get 35% of price
                                modPrice = modPrice - per; // subtract percentage
                                modPrice = Math.round(modPrice); //clean price

                                if (modPrice > 0){

                                    //add price param
                                    amazonParams.MaximumPrice = modPrice.toString();

                                    //now resolving the search term param
                                    var itemAttrib = data.recallHistory.amazon[searchSelect].ItemAttributes[0];
                                    var cSearch = '';

                                    if (itemAttrib.Department){
                                        cSearch = cSearch + ' ' + itemAttrib.Department[0];
                                    }
                                    if (itemAttrib.ProductGroup){
                                        cSearch = cSearch + ' ' + itemAttrib.ProductGroup[0];
                                    }
                                    if (itemAttrib.Binding){
                                        cSearch = cSearch + ' ' + itemAttrib.Binding[0];
                                    }
                                    if (itemAttrib.Color){
                                        cSearch = cSearch + ' ' + itemAttrib.Color[0];
                                    }
                                    if (itemAttrib.ClothingSize){
                                        cSearch = cSearch + ' ' + itemAttrib.ClothingSize[0];
                                    }

                                    amazonParams.Keywords = cSearch;
                
                                    doSearch();
                                }
                                else {
                                    doSearch();
                                    console.log('Error: not allowing search for max price below 0');
                                }

                            }
                            else {
                                doSearch();
                                console.log('error: amazon price missing');
                            }

                            break;

                        // case 'less than':
                        //     console.log('less than');

                        //     //check if val is real number
                        //     if (flag.val && isNumber(flag.val[0])){

                        //         console.log('FIRING less than ',data.searchSelect.length);

                        //         //WARNING: THIS SUCKS AND IS INACCURATE / TOO SPECIFIC OF A QUERY RIGHT NOW. USE WEAK SEARCHER

                        //         //user wanted one item at different price

                        //         if (data.searchSelect.length == 1){

                        //             var searchSelect = data.searchSelect[0];

                        //             if (data.recallHistory && data.recallHistory.amazon && data.recallHistory.amazon[searchSelect - 1].ItemAttributes[0].Title){
                        //                 amazonParams.Keywords = data.recallHistory.amazon[searchSelect - 1].ItemAttributes[0].Title;

                        //                 amazonParams.MaximumPrice = flag.val[0];
                        //                 amazonParams.MaximumPrice = parseInt(amazonParams.MaximumPrice); //remove any decimals
                        //                 amazonParams.MaximumPrice = amazonParams.MaximumPrice.toString() + '00'; //add amazon friendly decimal


                        //                 console.log('params ',amazonParams);
                        //             }
                        //             else {
                        //                 console.log('Error: Title is missing from amazon itemattributes object');
                        //             }
                        //         }
                        //         else {
                        //             console.log('Warning: no single item selected for less than (not supporting multiple), so resorting to less than N original query from user')
                        //             amazonParams.MaximumPrice = flag.val[0];
                        //             amazonParams.MaximumPrice = parseInt(amazonParams.MaximumPrice); //remove any decimals
                        //             amazonParams.MaximumPrice = amazonParams.MaximumPrice.toString() + '00'; //add amazon friendly decimal
                        //             amazonParams.Keywords = data.recallHistory.tokens[0];
                        //         }
                        //     }
                        //     else {
                        //         console.log(' number not used in flag.val with flag.modify == price');
                        //     }
                        //     break;
                        case 'more':
                            doSearch();

                            break;
                        case 'more than':
                            doSearch();
                            break;

                        default:
                            console.log('error: no flag.param found with flag.modify == price');
                            doSearch();
                    }
                }
                else if (flag.type == 'brand'){
                    console.log('BRAND FIRED');
                    doSearch();
                }
                else {
                    doSearch();
                }
            }
            else {
                doSearch();
            }

            //console.log('amazonParams ',amazonParams);

            function doSearch(){
                //AMAZON BASIC SEARCH
                client.itemSearch(amazonParams).then(function(results,err){
                    data.amazon = results;

                    var loopLame = [0,1,2];//lol
                    async.eachSeries(loopLame, function(i, callback) {
                        if (data.amazon[i]){
                            //get reviews by ASIN 
                            search.getReviews(data.amazon[i].ASIN[0],function(rating,reviewCount){
                                //adding scraped reviews to amazon objects
                                data.amazon[i].reviews = {
                                    rating: rating,
                                    reviewCount: reviewCount
                                }

                                //GET PRICE
                                search.getPrices(data.amazon[i],function(realPrice){
                                    data.amazon[i].realPrice = realPrice;
                                    callback();
                                });

                            });
                        }
                        else {
                            callback();
                        }
                    }, function done(){
                        outgoingResponse(data,'stitch','amazon'); //send back msg to user
                    });

                }).catch(function(err){

                    //handle err codes. do stuff.
                    if (err[0].Error[0].Code[0]){
                        switch (err[0].Error[0].Code[0]) {

                            //CASE: No results for search
                            case 'AWS.ECommerceService.NoExactMatches':
                                //do a weak search
                                weakSearch(data,type,query,flag);
                                break;

                            default:
                                console.log('amazon err ',err[0].Error[0]);
                                //no results after weaksearch, now do:
                                sendTxtResponse(data,'Sorry, it looks like we don\'t have that available. Try another search?');
                        }
                    }
                });
            }

            break;

        // * * * * * * * * * * * * * *//

        case 'similar':
            //handle no data error
            if (!data){
                console.log('error no amazon item found for similar search');

                var msg = 'Sorry, I don\'t understand, please ask me again';
                cannedBanter(data,msg);
                //outgoingResponse(data,'txt');
            }
            else {

                if (data.recallHistory && data.recallHistory.amazon){ //we have a previously saved amazon session

                    if (!flag){ //no flag passed in
                        flag = 'Intersection'; //default
                    }

                    //GATHER AMAZON IDS FROM USER SEARCH SELECTIONS
                    var IdArray = [];
                    for (var i = 0; i < data.searchSelect.length; i++) { //match item choices to product IDs
                        var searchNum = data.searchSelect[i];
                        IdArray.push(data.recallHistory.amazon[searchNum - 1].ASIN[0]);
                    }
                    var ItemIdString = IdArray.toString();
                    //////////

                    //AMAZON SIMILARITY QUERY
                    // [NOTE: functionality not in default AWS node lib. had to extend it!]
                    client.similarityLookup({
                      ItemId: ItemIdString, //get search focus items (can be multiple) to blend similarities
                      // Keywords: data.recallHistory.tokens,
                      SimilarityType: flag, //other option is "Random" <<< test which is better results
                      responseGroup: 'ItemAttributes,Images,OfferFull'

                    }).then(function(results){

                        //console.log('RESULTS SIMILAR ',results);

                        data.amazon = results;

                        var loopLame = [0,1,2];//lol
                        async.eachSeries(loopLame, function(i, callback) {

                            if (data.amazon[i]){
                                //get reviews by ASIN 
                                search.getReviews(data.amazon[i].ASIN[0],function(rating,reviewCount){
                                    //adding scraped reviews to amazon objects
                                    data.amazon[i].reviews = {
                                        rating: rating,
                                        reviewCount: reviewCount
                                    }

                                    //GET PRICE
                                    search.getPrices(data.amazon[i],function(realPrice){
                                        data.amazon[i].realPrice = realPrice;
                                        callback();
                                    });
                                });
                            }

                        }, function done(){
                            data.action = 'initial';
                            outgoingResponse(data,'stitch','amazon'); //send back msg to user
                        });

                    }).catch(function(err){
                        console.log('amazon err ',err[0].Error[0]);
                        console.log('SIMILAR FAILED: should we fire random query or mod query');

                        var cSearch = '';
                        var itemAttrib = data.recallHistory.amazon[data.searchSelect - 1].ItemAttributes; //get selected item attributes

                        if (itemAttrib[0].Brand){
                            cSearch = cSearch + ' ' + itemAttrib[0].Brand[0];
                        }
                        if (itemAttrib[0].Department){
                            cSearch = cSearch + ' ' + itemAttrib[0].Department[0];
                        }
                        if (itemAttrib[0].ProductGroup){
                            cSearch = cSearch + ' ' + itemAttrib[0].ProductGroup[0];
                        }
                        if (itemAttrib[0].Binding){
                            cSearch = cSearch + ' ' + itemAttrib[0].Binding[0];
                        }

                        console.log('BS string ugh ',cSearch);

                        data = data.recallHistory; //HACK!!!!!!
                        data.tokens = [];
                        data.tokens.push(cSearch);
                        searchAmazon(data,'initial'); //if amazon id doesn't exist, do init search instead
                        //searchAmazon(data, type, query, 'Random'); //if no results, retry search with random

                    });
                }
                else {
                    console.log('warning: there was a data error resolving to basic search');
                    searchAmazon(data,'initial'); //if amazon id doesn't exist, do init search instead
                }
            }
            break;

        case 'focus':
            break;
        default:
    }
}


//re-search but with less specific terms
function weakSearch(data,type,query,flag){
    //sort incoming flags for redundant searches
    switch (flag) {
        case 'weakSearch': //we already did weakSearch
            console.log('ALREADY TRIED weakSearch FLAG!');
            if (data.dataModify){
                if (data.dataModify.param){
                    var modDetail = data.dataModify.param;
                }else {
                    var modDetail = data.dataModify.val;
                }
                sendTxtResponse(data,'Sorry, it looks like we don\'t have that with' + modDetail + '. Would you like to do another search? Need help? Chat `help`.');
            }
            else {
                //no results after weaksearch, now do:
                sendTxtResponse(data,'Sorry, it looks like we don\'t have it available. Try another search?');
            }
            break;
        default:
            //no results, trying weak search
            console.log('no results');

            //select weakSearch action (initial, modify, etc)
            switch (data.action) {
                case 'modify':
                    if (data.dataModify && data.dataModify.type == 'price'){
                        console.log('cant find lower price item, preventing infinite loop');
                        sendTxtResponse(data,'Sorry, it looks like we don\'t have it available. Try another search?');
                    }
                    else {
                        searchModify(data, 'weakSearch');
                    }
                    break;
                default:
                    console.log('warning: weak search not enabled for '+ data.action);
                    sendTxtResponse(data,'Sorry, it looks like we don\'t have it available. Try another search?');
            }
    }
}

/////////// OUTGOING RESPONSES ////////////


//process canned message stuff
//data: kip data object
function cannedBanter(data){
    data.bucket = 'banter';
    data.action = 'smalltalk';
    incomingAction(data);
}

function sendTxtResponse(data,msg){
    data.action = 'smallTalk';
    if (!msg){
        console.log('error: no message sent with sendTxtResponse(), using default');
        msg = 'Sorry, I didn\'t understand';
    }
    data.client_res = [];
    data.client_res.push(msg);
    sendResponse(data);
}

//Constructing reply to user
function outgoingResponse(data,action,source){ //what we're replying to user with
    //stitch images before send to user
    if (action == 'stitch'){
        picstitch.stitchResults(data,source,function(url){

            //sending out stitched image response
            data.client_res = [];
            data.urlShorten = [];
            data.client_res.push(url); //add image results to response

            //send extra item URLs with image responses
            if (data.action == 'initial' || data.action == 'similar' || data.action == 'modify'){
                processData.urlShorten(data,function(res){
                    var count = 0;
                    //put all result URLs into arr
                    async.eachSeries(res, function(i, callback) {
                        data.urlShorten.push(i);//save shortened URLs
                        processData.getNumEmoji(data,count+1,function(emoji){
                            data.client_res.push(emoji + ' ' + res[count]);
                            count++;                           
                            callback();
                        });
                    }, function done(){
                        checkOutgoingBanter(data);
                    });
                });
            }
            else {
                checkOutgoingBanter(data);
            }
        });
    }

    else if (action == 'txt'){  
        sendResponse(data);
        banter.getCinnaResponse(data,function(res){
            if(res && res !== 'null'){
                data.client_res = [];
                data.client_res.push(res);
                sendResponse(data);
            }
        });
    }
    //no cinna response check
    else if (action == 'final'){
        sendResponse(data);
    }
}

//check for extra banter to send with message. 
function checkOutgoingBanter(data){
    banter.getCinnaResponse(data,function(res){
        if(res && res !== 'null'){
            data.client_res.unshift(res); // add to beginning of message
            sendResponse(data);
        }
        else {
            sendResponse(data);
        }
    });            
}

//send back msg to user, based on source.origin
function sendResponse(data){

    if (data.source.channel && data.source.origin == 'socket.io'){
        //check if socket user exists
        if (io.sockets.connected[data.source.channel]){
            //loop through responses in order
            for (var i = 0; i < data.client_res.length; i++) { 
                io.sockets.connected[data.source.channel].emit("msgFromSever", {message: data.client_res[i]});
            }            
        }else {
            console.log('error: socket io channel missing');
        }

    }
    else if (data.source.channel && data.source.origin == 'slack'){
        //eventually cinna can change emotions in this pic based on response type
        var params = {
            icon_url: 'http://kipthis.com/img/kip-icon.png'
        }   
        //check if slackuser exists
        if (slackUsers[data.source.org]){


            //loop through responses in order
            async.eachSeries(data.client_res, function(message, callback) {
                slackUsers[data.source.org].postMessage(data.source.channel, message, params).then(function(res) {
                    callback();
                });
            }, function done(){
            });

        }else {
            console.log('error: slackUsers channel missing');
        }
    }
    else {
        console.log('error: data.source.channel or source.origin missing')
    }

    //SAVE OUTGOING MESSAGES TO MONGO
    if (data.bucket && data.action){
        console.log('SAVING OUTGOING RESPONSE');
        //history.newMessage(data, function(newMsg){
        history.saveHistory(data,false); //saving outgoing message
        //});        
    }
    else {
        console.log('error: cant save outgoing response, missing bucket or action');
    }
}

////////////// HISTORY ACTIONS ///////////////

//get user history
function recallHistory(data,callback,steps){
    if (!data.source.org || !data.source.channel){
        console.log('missing channel or org Id 3');
    }

    //if # of steps to recall
    if (!steps){
        var steps = 1;
    }
    //get by bucket type
    switch (data.bucket) {
        case 'search':
            //console.log(data);

            switch(data.action){
                //if action is focus, find lastest 'initial' item
                case 'focus':
                    var result = messageHistory[data.source.id].search.filter(function( obj ) {
                      return obj.action == 'initial';
                    });
                    var arrLength = result.length - steps;
                    callback(result[arrLength]);
                    break;

                default:
                    var arrLength = messageHistory[data.source.id].search.length - steps; //# of steps to reverse. default is 1
                    callback(messageHistory[data.source.id].search[arrLength]); //get last item in arr
                    break;
            }

            break;
        case 'banter':
            var arrLength = messageHistory[data.source.id].banter.length - steps; //# of steps to reverse. default is 1
            callback(messageHistory[data.source.id].banter[arrLength]); //get last item in arr
            break;
        case 'purchase':
            var arrLength = messageHistory[data.source.id].purchase.length - steps; //# of steps to reverse. default is 1
            callback(messageHistory[data.source.id].purchase[arrLength]); //get last item in arr
        default:
    }

}


///////////////////////////////////////////
//////////  tools /////////////////
//////////////////////////////////////////

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function addDecimal(str) {
    var output;
    var num = parseInt(str);
    num = num * .10 * .10; //move decimal
    num = Math.round(num * 100) / 100; //remove extra decimal
    output = "$" + num.toString();
    return output;
}
